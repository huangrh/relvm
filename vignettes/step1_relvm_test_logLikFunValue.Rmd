---
title: "Random Effect Latent Variable Model"
author: "Ren-Huai Huang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r data}
require(rstarating)
require(relvm)
# Prepare to fit
# start of the cycle
set.seed(100)
idx <-unique(sample(1:4557,300))
x <- object <- mstbl(cms2016oct_input)
subdat    <- subgroup(x)
score <- score_tbl <- mstbl_std <- as.matrix(subdat$outcome_safty$mstbl_std)
wts <- wts_tbl     <- as.matrix(subdat$outcome_safty$wtbl)

# Setup and initialize the parameters
nc <- ncol(mstbl_std);

par <- init <- unlist(list(mu  = rep(0, nc),
                    fl  = rep(1, nc),
                    err = rep(1, nc)))

qpoints= 30
cc <- pracma::gaussHermite(qpoints);

dnorm2 <- function(x,mean=0,sd=1) {-(log(2 * pi) +2*log(sd)+((x-mean)/sd)^2)/2}

```

```{r v11, echo = FALSE}
# repreduce mark's code. set the variance to 1. 
set.seed(100)
v=1
# speedup Vectorized Estimation function
venll11 <- function(par,score,wts,cc,qpoints) {
    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    # coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    coefs <- rep(sqrt(2),nr)
    
    # fv matrix
    fv_mtx  <- cc$x %o% coefs

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll11(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
# microbenchmark::microbenchmark(re1 = venll11(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r 10short, echo = FALSE}
set.seed(100)
adaptive = "ad"
# try adaptive
venll10s <- function(par,score,wts,cc,qpoints) {
    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu <- par[grepl("mu", names(par))]         #
    fl <- par[grepl("fl", names(par))]         # factor loading
    err<- par[grepl("err", names(par))]
    
    # Sigma
    # hessian = (rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1)
    # coefs <- sqrt(2/hessian) # sd <- 1/sqrt(fit$hessian)
    # coefs <- 1.41421356237/(fitall$stderr)
    sigma <- switch(adaptive, 
           ad = {
               fitall <- relvm:::pred(score_tbl=score, wts_tbl=wts, pms=list(mu=mu,fl=fl,err=err));
               u_hat  <- t(array(fitall[,"pred"],dim=c(nr,qpoints)));
               fitall[,"stderr"];
               },
           noad= {
               u_hat <- array(0,dim=c(qpoints,nr));
               sqrt(1/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1));
               })
    
    coefs <- 1.41421356237 * sigma # sqrt(2) = 1.4142
    # coefs <- rep(mean(coefs),length(coefs))
    
    # fv matrix
    fv_mtx  <-  cc$x %o% coefs + u_hat

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll10s(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
microbenchmark::microbenchmark(re1 = venll10s(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r v9 from 7, echo = FALSE}
# Try algorithm of smith(1995)
set.seed(100)

# speedup Vectorized Estimation function
venll9 <- function(par,score,wts,cc,qpoints) {
    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # first derivetive 
    fd  <- function(fv) -rowSums(fl*wts*(score-fl*fv-mu)/err^2, na.rm=TRUE)+fv
    fd  <- fd(0)
    
    # 2nd derivative
    fdd <- rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1
    
    # coefs
    L11 = 1
    L11x = 0.5*fd
    coefs = rep(sqrt(2),)
    
    
    # coefs_1 <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_mtx  <- cc$x %o% coefs

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll9(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
# microbenchmark::microbenchmark(re1 = venll9(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r v8, echo = FALSE}
set.seed(100)
idx =1295

# speedup Vectorized Estimation function
venll8 <- function(par,score,wts,cc,qpoints) {
    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    coefs <- sqrt(2/(rowSums((fl^2 * wts[rep(idx,nrow(wts)),]/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_mtx  <- cc$x %o% coefs

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll8(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
# microbenchmark::microbenchmark(re1 = venll8(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll8(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r v7, echo = FALSE}
set.seed(100)

# speedup Vectorized Estimation function
venll7 <- function(par,score,wts,cc,qpoints) {
    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_mtx  <- cc$x %o% coefs

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
microbenchmark::microbenchmark(re1 = venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r v6, echo = FALSE}
set.seed(100)

# Vectorized Estimation function
venll6 <- function(par,score,wts,cc,qpoints) {

    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_m  <- cc$x %o% coefs

    # 3D array: 
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    # Weighted log likelyhood
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll6(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
microbenchmark::microbenchmark(re1 = venll6(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll6(par=init,score=mstbl_std, wts=wts_tbl,cc))

```

```{r}
microbenchmark::microbenchmark(dnorm(1:867930))
microbenchmark::microbenchmark(denfn(1:867930))
microbenchmark::microbenchmark(dnorm2(1:867930))
microbenchmark::microbenchmark(denfn3(1:867930,rep(0,867930),rep(1,867930)))
microbenchmark::microbenchmark(1 + (1:867930)^2+1+1)
denfn <- function(x,mean=0,v=1) {-log(2 * pi * v)/2-(x-mean)^2/2/v}

dnorm2 <- function(x,mean=0,sd=1) {-(log(2 * pi) +2*log(sd)+((x-mean)/sd)^2)/2}
```


```{r v5, echo = FALSE}
set.seed(100)

# Vectorized Estimation function
venll5 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    #
    fv_m  <- cc$x %o% coefs

    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll5(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll5(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll5(par=init,score=mstbl_std, wts=wts_tbl,cc))
```


```{r v4, echo = FALSE}
set.seed(100)

fn2ndv2 <-  function (fl, err, wt)  sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)

# Vectorized Estimation function
venll4 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- apply(wts,1, function(wts_row) {sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)})
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll4(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll4(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll4(par=init,score=mstbl_std, wts=wts_tbl,cc))
```

```{r v3, echo = FALSE}
set.seed(100)

fn2ndv2 <-  function (fl, err, wts_row)  sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)

# Vectorized Estimation function
venll3 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- vapply(1:nr, function(idx) {
        wts_row   <- wts[idx,];
        fn2ndv2(fl, err, wts_row)},FUN.VALUE = double(1))
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll3(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll3(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))
```

```{r v2, echo = FALSE}
require(pracma)


set.seed(100)
# For hessian computation only
fn_hessian <- function(fv,mu,fl,err,wts_row,score_row) {
    -sum(wts_row * dnorm(score_row, mean=mu + fl * fv, sd = err, log=TRUE),
         dnorm(fv, mean=0,sd=1,log=TRUE),na.rm=TRUE)
}

# Vectorized Estimation function
venll2 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- vapply(1:nr, function(idx) {
        
        wts_row   <- wts[idx,]
        score_row <- score[idx,]
        hessian(fn_hessian,0,mu=mu,fl=fl,err=err,wts_row=wts_row,score_row=score_row)
    },FUN.VALUE = double(1))
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}

venll2(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))

```



```{r v1, echo = FALSE}
# Vectorized Estimation function
venll <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  qpoints= qpoints) {
    
    # Setup the parameters
    nr <- nrow(score);
    cc <- pracma::gaussHermite(qpoints);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[gsub("\\d","", names(par)) %in% "mu"]         #
    fl    <- par[gsub("\\d","", names(par)) %in% "fl"]         # factor loading
    err   <- par[gsub("\\d","", names(par)) %in% "err"]
    
    # For rows of the mstbl_std and wts_tbl
    coefs  <- sapply(1:nr, function(idx) {
        # For hessian computation only
        fn <- function(fv) {
            means <- mu + fl * fv
            out1  <- wts_row * (dnorm(score_row, mean=means, sd = err, log=TRUE))
            out2  <- dnorm(fv, mean=0,sd=1,log=TRUE)
            -sum(out1,out2,na.rm=TRUE)
        }

        # Calculation
        wts_row   <- as.matrix(wts[idx,])
        score_row <- as.matrix(score[idx,])
        (coef     <- sqrt(2 / pracma::hessian(fn,0))) # pracma::hessian or numDeriv::hessian
    })
    
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll(par=init,score=mstbl_std, wts=wts_tbl,qpoints=30)
# microbenchmark::microbenchmark(re1 = venll(par=init,score=mstbl_std, wts=wts_tbl,qpoints=30))
```


```{r v0, echo = FALSE}
# function value = 27220.89
idx = 1295
#(wts_row = wts_tbl[idx,])
#score_row = mstbl_std[idx,]

# Vectorized Estimation function
venll0 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  qpoints= qpoints) {
    
    # Setup the parameters
    nr <- nrow(score);
    cc <- pracma::gaussHermite(qpoints);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[gsub("\\d","", names(par)) %in% "mu"]         #
    fl    <- par[gsub("\\d","", names(par)) %in% "fl"]         # factor loading
    err   <- par[gsub("\\d","", names(par)) %in% "err"]
    # For hessian computation only
    
    fn <- function(fv) {
        means <- mu + fl * fv
        out1  <- wts_row * (dnorm(score_row, mean=means, sd = err, log=TRUE))
        out2  <- dnorm(fv, mean=0,sd=1,log=TRUE)
        -sum(out1,out2,na.rm=TRUE)
    }

    # For rows of the mstbl_std and wts_tbl
    coefs  <- sapply(1:nr, function(idx) {


        # Calculation
        wts_row   <- as.matrix(wts[idx,])
        score_row <- as.matrix(score[idx,])
        (coef     <- sqrt(2 / pracma::hessian(fn,0))) # pracma::hessian or numDeriv::hessian
    })
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll0(par=init,score=mstbl_std, wts=wts_tbl,qpoints=30)
microbenchmark::microbenchmark(re1 = venll0(par=init,score=mstbl_std, wts=wts_tbl,qpoints=30))
```
```{r}

```


```{R}
start_time = Sys.time()
#--------------------------------------------------------#
# Fit the function
fit <- optim(par     = init,     # Model parameter
             fn      = venll,    # Estimation function
             gr      = NULL,
             method  = "L-BFGS",
             control = list(maxit=1000),
             hessian = FALSE,
             score   = mstbl_std,
             wts     = wts_tbl,
             qpoints = qpoints)
Sys.time()-start_time
```










