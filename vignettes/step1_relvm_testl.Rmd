---
title: "Random Effect Latent Variable Model"
author: "Ren-Huai Huang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r data}
require(rstarating)
# Prepare to fit
# start of the cycle
start_time = Sys.time()
# data table & weight table
qpoints   = 30
set.seed(100)
idx <-unique(sample(1:4557,300))
cms300 <- cms2016oct_input
object <- mstbl(cms300)
group <- "outcome_mort"

df        <- merge(x=object$mstbl_std, y=object$wtbl, all=TRUE)
subdat    <- relvm:::sub1group(group,df)
score <- mstbl_std <- as.matrix(subdat$mstbl_std)
wts <- wts_tbl   <- as.matrix(subdat$wtbl)

# Setup and initialize the parameters
nc <- ncol(mstbl_std);

par <- init <- unlist(list(mu  = rep(0.5, nc),
                    fl  = rep(0.5, nc),
                    err = rep(0.5, nc)))

qpoints= 30
cc <- pracma::gaussHermite(qpoints);

dnorm2 <- function(x,mean=0,sd=1) {-(log(2 * pi) +2*log(sd)+((x-mean)/sd)^2)/2}

```

```{r v7, echo = FALSE}
set.seed(100)

# Vectorized Estimation function
venll7 <- function(par,score,wts,cc,qpoints) {

    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_mtx  <- cc$x %o% coefs

    # 3D array: 
    wts_arr   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_arr <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_arr <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_mtx
    
    # Weighted log likelyhood
    wll_mtx   <- colSums(wts_arr * dnorm2(score_arr, mean=means_arr, sd = err),na.rm=TRUE)
    
    # Joint probability
    joint_mtx <- wll_mtx +  dnorm_cpp(fv_mtx, mean=0,sd=1)
    
    # Gaussian quadrature integral approximation
    gqi <- matrixStats::colLogSumExps(joint_mtx + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
microbenchmark::microbenchmark(re1 = venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll7(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))

```

```{r v6, echo = FALSE}
set.seed(100)

# Vectorized Estimation function
venll6 <- function(par,score,wts,cc,qpoints) {

    # Reconstruction of the parameters
    nr <- nrow(score); nc <- ncol(score)
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # 2nd derivative
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    # fv matrix
    fv_m  <- cc$x %o% coefs

    # 3D array: 
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    # Weighted log likelyhood
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll6(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints)
microbenchmark::microbenchmark(re1 = venll6(par=init,score=mstbl_std, wts=wts_tbl,cc,qpoints))
# l <- lineprof::lineprof(venll6(par=init,score=mstbl_std, wts=wts_tbl,cc))

```

```{r}
microbenchmark::microbenchmark(dnorm(1:867930))
microbenchmark::microbenchmark(denfn(1:867930))
microbenchmark::microbenchmark(dnorm2(1:867930))
microbenchmark::microbenchmark(denfn3(1:867930,rep(0,867930),rep(1,867930)))
microbenchmark::microbenchmark(1 + (1:867930)^2+1+1)
denfn <- function(x,mean=0,v=1) {-log(2 * pi * v)/2-(x-mean)^2/2/v}

dnorm2 <- function(x,mean=0,sd=1) {-(log(2 * pi) +2*log(sd)+((x-mean)/sd)^2)/2}
```


```{r v5, echo = FALSE}
set.seed(100)

# Vectorized Estimation function
venll5 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    coefs <- sqrt(2/(rowSums((fl^2 * wts/err^2), na.rm = TRUE) + 1))
    
    #
    fv_m  <- cc$x %o% coefs

    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll5(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll5(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll5(par=init,score=mstbl_std, wts=wts_tbl,cc))
```


```{r v4, echo = FALSE}
set.seed(100)

fn2ndv2 <-  function (fl, err, wt)  sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)

# Vectorized Estimation function
venll4 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- apply(wts,1, function(wts_row) {sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)})
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll4(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll4(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll4(par=init,score=mstbl_std, wts=wts_tbl,cc))
```

```{r v3, echo = FALSE}
set.seed(100)

fn2ndv2 <-  function (fl, err, wts_row)  sum((fl^2 * wts_row/err^2), 1, na.rm = TRUE)

# Vectorized Estimation function
venll3 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- vapply(1:nr, function(idx) {
        wts_row   <- wts[idx,];
        fn2ndv2(fl, err, wts_row)},FUN.VALUE = double(1))
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
venll3(par=init,score=mstbl_std, wts=wts_tbl,cc)
microbenchmark::microbenchmark(re1 = venll3(par=init,score=mstbl_std, wts=wts_tbl,cc))
# l <- lineprof::lineprof(venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))
```

```{r v2, echo = FALSE}



set.seed(100)
# For hessian computation only
fn_hessian <- function(fv,mu,fl,err,wts_row,score_row) {
    -sum(wts_row * dnorm(score_row, mean=mu + fl * fv, sd = err, log=TRUE),
         dnorm(fv, mean=0,sd=1,log=TRUE),na.rm=TRUE)
}

# Vectorized Estimation function
venll2 <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  cc=cc) {
    
    # Setup the parameters
    nr <- nrow(score);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[grepl("mu", names(par))]         #
    fl    <- par[grepl("fl", names(par))]         # factor loading
    err   <- par[grepl("err", names(par))]
    
    # For rows of the mstbl_std and wts_tbl
    hessian_coefs  <- vapply(1:nr, function(idx) {
        
        wts_row   <- wts[idx,]
        score_row <- score[idx,]
        hessian(fn_hessian,0,mu=mu,fl=fl,err=err,wts_row=wts_row,score_row=score_row)
    },FUN.VALUE = double(1))
    
    coefs <- sqrt(2/hessian_coefs)
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
microbenchmark::microbenchmark(re1 = venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))
venll2(par=init,score=mstbl_std, wts=wts_tbl,cc)
# l <- lineprof::lineprof(venll2(par=init,score=mstbl_std, wts=wts_tbl,cc))

```



```{r v1, echo = FALSE}
# Vectorized Estimation function
venll <- function(par,
                  score = mstbl_std,
                  wts   = wts_tbl,
                  qpoints= qpoints) {
    
    # Setup the parameters
    nr <- nrow(score);
    cc <- pracma::gaussHermite(qpoints);
    nc <- ncol(score);
    
    # Reconstruction of the parameters
    mu    <- par[gsub("\\d","", names(par)) %in% "mu"]         #
    fl    <- par[gsub("\\d","", names(par)) %in% "fl"]         # factor loading
    err   <- par[gsub("\\d","", names(par)) %in% "err"]
    
    # For rows of the mstbl_std and wts_tbl
    coefs  <- sapply(1:nr, function(idx) {
        # For hessian computation only
        fn <- function(fv) {
            means <- mu + fl * fv
            out1  <- wts_row * (dnorm(score_row, mean=means, sd = err, log=TRUE))
            out2  <- dnorm(fv, mean=0,sd=1,log=TRUE)
            -sum(out1,out2,na.rm=TRUE)
        }
        
        # Calculation
        wts_row   <- as.matrix(wts[idx,])
        score_row <- as.matrix(score[idx,])
        (coef     <- sqrt(2 / pracma::hessian(fn,0))) # pracma::hessian or numDeriv::hessian
    })
    
    #
    fv_m  <- cc$x %o% coefs
    wts   <- as.matrix(wts)
    score <- as.matrix(score)
    
    # Weighted log likelyhood
    wts_a   <- aperm(array(wts,  dim=c(nr,nc,qpoints)),c(2,3,1))
    score_a <- aperm(array(score,dim=c(nr,nc,qpoints)),c(2,3,1))
    means_a <- array(mu,         dim=c(nc,qpoints,nr)) + fl %o% fv_m
    
    wll_m   <- colSums(wts_a * (dnorm(score_a, mean=means_a, sd = err, log=TRUE)),na.rm=TRUE)
    
    # Joint probability
    joint_m <- wll_m +  (dnorm(fv_m, mean=0,sd=1,log=TRUE))
    
    # Gaussian quadrature integral approximation
    # gqi <- log(sum(exp(joint + log(cc$w) +(cc$x)^2),na.rm=TRUE))
    gqi <- matrixStats::colLogSumExps(joint_m + log(cc$w) +(cc$x)^2,na.rm=TRUE)
    -sum(log(coefs)+gqi, na.rm=TRUE)
}
microbenchmark::microbenchmark(re1 = venll(par=init,score=mstbl_std, wts=wts_tbl,qpoints=30))
```

```{r}

```


```{R}
start_time = Sys.time()
#--------------------------------------------------------#
# Fit the function
fit <- optim(par     = init,     # Model parameter
             fn      = venll,    # Estimation function
             gr      = NULL,
             method  = "L-BFGS",
             control = list(maxit=1000),
             hessian = FALSE,
             score   = mstbl_std,
             wts     = wts_tbl,
             qpoints = qpoints)
Sys.time()-start_time
```

```{r}
require(microbenchmark)
set.seed(101)
N <- 100
x <- rnorm(N, mean=3,sd = 2)
mean(x);sd(x)
init2 = c(mu=1,sigma=1)

nLL <- function(par = init) {
    - sum(dnorm(x,par["mu"],par["sigma"],log=TRUE))
}

microbenchmark(fit <- optim(par=init2,nLL))
fit

```






